var Loader = require("Dune/Loader");
var canvasContainer = require("Dune/CanvasContainer");
var mapView = require("Dune/View/Map");
var shuffleArray = require("Dune/shuffle");

module.exports = new PolarSinkView();

function PolarSinkView() {

  var loader = new Loader();

  var occupyingFactions = {};
  var troopQuadrants;

  var circle = mapView.circle;

  var troopIconSize = 8.5;
  var imageScaleFactor, imageScaleWidth, imageScaleHeight;

  var imageUrl = "/img/territories/polarSink.png";
  var image = loader.loadImage(imageUrl);

  var smallCoords = getMapOverviewTerritoryCoordinates();
  var largeCoords = [];;

  loader.onload = function() {
    calculateImageScaleFactor();
    setImageCoordinates();
    troopQuadrants = calculateTroopQuadrants();
  }

  function calculateImageScaleFactor() 
  {
    var largestTerritorySide = Math.max(image.width, image.height);
    imageScaleFactor = 2 * circle.radius / largestTerritorySide;

    imageScaleWidth = image.width * imageScaleFactor;
    imageScaleHeight = image.height * imageScaleFactor;
  }

  function getMapOverviewTerritoryCoordinates() {
    var areaTags = document.getElementsByTagName("area");

    for (var i = 0; i < areaTags.length; i++) {
      var areaTag = areaTags[i];

      if (areaTag.target == "polarSink") {
	var coords = areaTag.coords.split(',');
	return coords;
      }
    }
  }

  this.addFaction = function(factionImage) {

    var faction = factionImage.faction.constructor.name;

    if (occupyingFactions[faction]) {
      occupyingFactions[faction].troops.push(factionImage);

    } else {

      occupyingFactions[faction] = {
      	"coords": undefined,
      	"scale": troopIconSize,
	"troops": [factionImage]
      };

      shuffleArray(troopQuadrants);


      var TO_RADIANS = Math.PI/180;

      var troopCircle = {
	"centerX": image.xPos + image.width/2,
	"centerY": image.yPos + image.height/2,
	"radius": 100,
	"angle": 0
      };

      var maxDiscs = 8;
      var maxAngle = 180/maxDiscs * TO_RADIANS;

      var maxTroopRadius = 
	troopCircle.radius / ( (1 - Math.sin(maxAngle)) 
	/ Math.sin(maxAngle) + 2 );

      troopIconSize = maxTroopRadius * 2;

      var numberOfDiscs = Object.keys(occupyingFactions).length
      var centralAngle = 180/numberOfDiscs * TO_RADIANS;

      var steinerCircleRadius = 
	troopCircle.radius / ( (1 - Math.sin(centralAngle)) 
	/ Math.sin(centralAngle) + 2 );

      var innerCircleRadius = steinerCircleRadius * (1/Math.sin(centralAngle) - 1);
      
      var degrees = 360 / numberOfDiscs;
      //for (var i = 0; i < numberOfDiscs; i++) {
      var i = 0;
      for (var f in occupyingFactions) { 
      	i++;

	troopCircle.angle = (i * degrees * TO_RADIANS); 

	// Rotate the angle for odd disc numbers to keep things symmetrical
	if (numberOfDiscs % 2) troopCircle.angle -= centralAngle/2;


	var distanceFromCenter = maxTroopRadius + innerCircleRadius;
	//if (numberOfDiscs == 1) distanceFromCenter = 0;
	if (numberOfDiscs == 1) distanceFromCenter = -maxTroopRadius;
	console.log('distanceFromCenter');
	console.log(distanceFromCenter);

	var x = troopCircle.centerX + Math.cos(troopCircle.angle) 
	  * distanceFromCenter;
	var y = troopCircle.centerY + Math.sin(troopCircle.angle) 
	  * distanceFromCenter;
	
	context.beginPath();
	context.arc(x, y,
	  maxTroopRadius, 0, 2 * Math.PI);
	context.strokeStyle = "green";
	context.stroke();

	console.log(troopCircle);
	console.log({"x": x, "y": y});

	occupyingFactions[f].coords = {"x": x, "y": y};
      }



    }

    console.log('occupyingFactions');
    console.log(occupyingFactions);
    return occupyingFactions[faction];
  }

  this.enlarge = function() {
    addCanvasClickEvent();
    drawTerritoryImage(largeCoords);
  }

  this.draw = function() {
    drawTerritoryImage(largeCoords);

  }

  function addCanvasClickEvent() {
    var canvas = canvasContainer.layer("notification");
    canvas.addEventListener('click', function(e) {
      canvasContainer.deleteLayer(canvas);
    });
  }

  function drawTerritoryImage(largeCoords) {

    var canvas = canvasContainer.layer("notification");
    context = canvas.getContext("2d");


    context.drawImage(image, 
      image.xPos, image.yPos,
      image.width, image.height
    );

    context.strokeStyle = "red";
    context.lineWidth = 1;

    //DEBUG draw territory quadrants outline
 /*   for(var i=0 ; i < troopQuadrants.length-1 ; i++ ) {*/
      //var troopQuadrant = troopQuadrants[i];
      //context.strokeRect(
                //troopQuadrant.x, troopQuadrant.y,
                //troopIconSize, troopIconSize
      //);
    /*}*/

    //DEBUG draw placement circle outline
    drawTroopCircle();
  
    //DEBUG draw territory bounding box outline
    context.strokeRect(image.xPos, image.yPos, image.width, image.height);


    drawOccupyingFactions();
  }

  function drawTroopCircle() {
    var TO_RADIANS = Math.PI/180;

    var troopCircle = {
      "centerX": image.xPos + image.width/2,
      "centerY": image.yPos + image.height/2,
      "radius": 100,
      "angle": 0
    };

    context.beginPath();
    context.arc(troopCircle.centerX, troopCircle.centerY, 
    	troopCircle.radius, 0, 2 * Math.PI);
    context.stroke();

    var maxDiscs = 8;
    var maxAngle = 180/maxDiscs * TO_RADIANS;
    var maxTroopRadius = 
      troopCircle.radius / ( (1 - Math.sin(maxAngle)) 
      / Math.sin(maxAngle) + 2 );


    var numberOfDiscs = 8;
    var centralAngle = 180/numberOfDiscs * TO_RADIANS;

    var troopRadius = 
      troopCircle.radius / ( (1 - Math.sin(centralAngle)) 
      / Math.sin(centralAngle) + 2 );

    var innerCircleRadius = troopRadius * (1/Math.sin(centralAngle) - 1);
    //var innerCircleRadius = maxTroopRadius * (1/Math.sin(maxAngle) - 1);
    

/*    context.beginPath();*/
    //context.arc(troopCircle.centerX, troopCircle.centerY, 
            //innerCircleRadius, 0, 2 * Math.PI);
    //context.strokeStyle = "green";
    /*context.stroke();*/

    for (var i = 0; i < numberOfDiscs; i++) {
      var degrees = 360 / numberOfDiscs;

      troopCircle.angle = (i * degrees * TO_RADIANS); 

      // Rotate the angle for odd disc numbers to keep things symmetrical
      if (numberOfDiscs % 2) troopCircle.angle -= centralAngle/2;


      var distanceFromCenter = maxTroopRadius + innerCircleRadius;
      if (numberOfDiscs == 1) distanceFromCenter = 0;

      var x = troopCircle.centerX + Math.cos(troopCircle.angle) 
	* distanceFromCenter;
      var y = troopCircle.centerY + Math.sin(troopCircle.angle) 
	* distanceFromCenter;
      
      context.beginPath();
      //context.arc(x, y, troopRadius, 0, 2 * Math.PI);
      context.arc(x, y, maxTroopRadius, 0, 2 * Math.PI);
      context.strokeStyle = "red";
      context.stroke();
    }
  }

  function drawOccupyingFactions() {
    for (var factionName in occupyingFactions) {
      var faction = occupyingFactions[factionName];
      var troops = faction.troops;
      var troopIcon = troops[0];
      var troopCoords = faction.coords;

      context.drawImage(troopIcon, 
	troopCoords.x, troopCoords.y
	,troopIconSize, troopIconSize
      );

      var troopCount = troops.length;

      var fontSize = 10;
      
      var textWidth = context.measureText(troopCount).width;

      var xPos = troopCoords.x + troopIconSize/2 - textWidth/2;
      var yPos = troopCoords.y + troopIconSize - fontSize/2;

      context.strokeStyle = "black";
      context.lineWidth = 5;
      context.strokeText(troopCount, xPos, yPos);

      context.fillStyle = "white";
      context.fillText(troopCount, xPos, yPos);
    }
  }

  function setImageCoordinates() {
    image.xPos = circle.centerX - imageScaleWidth/2; 
    image.yPos = circle.centerY - imageScaleHeight/2;
  }

  function calculateTroopQuadrants() {

    var rectangle = getTerritoryMinimumBoundingRectangle(smallCoords);

    var smallestX = rectangle.x
    var smallestY = rectangle.y

    var width = rectangle.width;
    var height = rectangle.height;

    var canvas = canvasContainer.layer("test");
    var context = canvas.getContext("2d");

    var scale = scaleCoordinatesToEnlargedTerritory(smallCoords, rectangle);

    drawTerritoryOutline(largeCoords, context);

    var quadrants = divideBoundingRectangleIntoQuadrants(scale);

    var troopQuadrants = getQuadrantsInsideTerritoryBoundary(quadrants, context);

    return troopQuadrants;
  }

  function getTerritoryMinimumBoundingRectangle(coords) {

    var smallestX = undefined,
	largestX = undefined, 
	smallestY = undefined,
	largestY = undefined; 

    for( i=2 ; i < coords.length-1 ; i+=2 )
    {
      var x= coords[i], y = coords[i+1];

      if (smallestX == undefined) { smallestX = x }
      else if (x < smallestX) { smallestX = x }

      if (smallestY == undefined) { smallestY = y }
      else if (y < smallestY) { smallestY = y }

      if (largestX == undefined) { largestX = x }
      else if (x > largestX) { largestX = x }

      if (largestY == undefined) { largestY = y }
      else if (y > largestY) { largestY = y }
    }

    var width = largestX - smallestX;
    var height = largestY - smallestY;

    var rectangle = {"x": smallestX, "y": smallestY, 
      "width": width, "height": height};

    return rectangle;
  }

  function scaleCoordinatesToEnlargedTerritory(coords, rectangle) {

    var xShift = coords[0] - image.xPos; 
    var yShift = coords[1] - image.yPos;

    var scaleX = image.width / rectangle.width;
    var scaleY = image.height/ rectangle.height;
    var scale = Math.max(scaleX, scaleY);

    for( i=0 ; i < coords.length-1 ; i+=2 )
    {
      var xShift = (rectangle.x * scale - image.xPos);
      var yShift = (rectangle.y * scale - image.yPos);

      largeCoords[i] = coords[i] * scale;
      largeCoords[i+1] = coords[i+1] * scale;

      largeCoords[i] -= xShift;
      largeCoords[i+1] -= yShift;
    }

    return scale;
  }

  function divideBoundingRectangleIntoQuadrants(coordScale) {
    var quadrants = [];

    troopIconSize *= coordScale;

    smallestX = image.xPos;
    smallestY = image.yPos;
    largestX = image.xPos + image.width;
    largestY = image.yPos + image.height;

    var x = smallestX;
    var y = smallestY;
    

    while (x < largestX && y < largestY) {

      quadrants.push({x: x, y: y});

      x += troopIconSize;

      if (x > largestX) {
	x = smallestX;
	y += troopIconSize;
      }

    }

    return quadrants;
  }

  function getQuadrantsInsideTerritoryBoundary(squarePoints, context) {

    var territorySquares = [];
    for (var i = 0; i < squarePoints.length; i++) {
      var coords = squarePoints[i];

      var topLeft = {"x": coords.x, "y": coords.y};
      var topRight = {"x": coords.x + troopIconSize, "y": coords.y};

      var bottomLeft = {"x": coords.x, "y": coords.y + troopIconSize};
      var bottomRight = 
	{"x": coords.x + troopIconSize, "y": coords.y + troopIconSize};

      if (
	context.isPointInPath(topLeft.x, topLeft.y) 
	&& context.isPointInPath(topRight.x, topRight.y)
	&& context.isPointInPath(bottomLeft.x, bottomLeft.y) 
	&& context.isPointInPath(bottomRight.x, bottomRight.y)
      ) {
	territorySquares.push(topLeft);

      }

    }

    return territorySquares;
  }

}

function drawTerritoryOutline(coords, ctx) {

  ctx.beginPath();
  ctx.moveTo(coords[0], coords[1]);
  for( item=2 ; item < coords.length-1 ; item+=2 ) {
    ctx.lineTo( coords[item] , coords[item+1] )
  }
  ctx.closePath();

}

