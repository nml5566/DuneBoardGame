module.exports = PlayerScreen;

var controller = require("Dune/Controller");

var canvasContainer = require("Dune/CanvasContainer");
var Loader = require("Dune/Loader");
var eventChain = require("Dune/EventChain");

var territoryView = require("Dune/View/Territory");

function PlayerScreen(args) 
{
  var images = args.images;

  var layerName = "playerscreen";

  var canvas = canvasContainer.layer(layerName),
      context = canvas.getContext("2d"),
      loader = new Loader();


  canvas.height = 172;

  var deckImgPath = "/img/deck/";

  var spiceIconImg,
      troopIconImg,
      treacheryDeckImg,
      traitorDeckImg,
      bonusDeckImg,
      allianceDeckImg;


  var troopReserveCount = 20;

  var traitorHand = [],
      treacheryHand = [],
      bonusHand = [],
      allianceHand = [];

  var iconScaleWidth = 67.5;
  var iconScaleHeight = 67.5;

  var deckScaleWidth = 100;
  var deckScaleHeight = 145;

  var padding = 10;

  var transparent = 0.5;
  var solid = 1;

  var that = this;

  this.draw = function() 
  {
    troopIconImg = images.troop;

    if (! images.troop.faction) 
      throw new Error ('Troop image has no faction property');

    troopIconImg.xPos = padding;
    troopIconImg.yPos = padding;
    troopIconImg.width = iconScaleWidth;
    troopIconImg.height = iconScaleHeight;

    var spiceIconImgUrl = "/img/icons/" + "spice-alt.png";
    spiceIconImg = loader.loadImage(spiceIconImgUrl);
    spiceIconImg.xPos = padding;
    spiceIconImg.yPos = troopIconImg.yPos + iconScaleHeight + padding;
    spiceIconImg.width = iconScaleWidth;
    spiceIconImg.height = iconScaleWidth;

    loadPlayerHandImages();

    context.fillStyle = "grey";
    context.fillRect(0, 0, canvas.width, canvas.height);

    canvas.redraw = drawPlayerScreen;

    loader.onload = function() { canvas.redraw() }

    //TODO refactor player screen or canvas so that it doesn't get multiple
    //onclick events
    if (! canvas.isInteractive) {
      canvas.isInteractive = true;
      canvas.addEventListener('click', function(element) {
	var coord = getMousePosition(canvas,element);

	var icons = new Array(
	  spiceIconImg,
	  troopIconImg,
	  treacheryDeckImg,
	  traitorDeckImg,
	  bonusDeckImg,
	  allianceDeckImg
	);

	for (var i = 0; i < icons.length; i++) {
	  var image = icons[i];

	  if (coord.x >= image.xPos && coord.x <= image.xPos + image.width
	      && coord.y >= image.yPos && coord.y <= image.yPos + image.height
	  ) {
	    console.log('clicked:');
	    console.log(image);
	  }

	}

	controller.startPlayerTurn();
      });
    }
  }

  this.update = function() {
    //TODO merge with this.draw
    canvas.redraw();
  }

  function drawPlayerScreen()
  {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = "grey";
    context.fillRect(0, 0, canvas.width, canvas.height);

    drawOffPlanetTroopReserves();

    context.drawImage(spiceIconImg, 
	spiceIconImg.xPos, spiceIconImg.yPos, 
	spiceIconImg.width, spiceIconImg.height);

    context.globalAlpha = transparent;

    drawPlayerHandImage(treacheryDeckImg, treacheryHand);
    drawPlayerHandImage(traitorDeckImg, traitorHand);
    drawPlayerHandImage(bonusDeckImg, bonusHand);
    drawPlayerHandImage(allianceDeckImg, allianceHand);

    context.globalAlpha = solid;

    drawLeaderDiscs();

    drawEndTurnButton();
  }

  function drawOffPlanetTroopReserves() {

    context.drawImage(troopIconImg, 
      troopIconImg.xPos, troopIconImg.yPos, 
      troopIconImg.width, troopIconImg.height);
      //iconScaleWidth, iconScaleHeight);

    drawTroopReserveCount();
  }

  function drawTroopReserveCount() {
    var fontSize = 12;
    context.font = fontSize + "pt Arial";
    
    var textWidth = context.measureText(troopReserveCount).width;

    // dead center
    //var xPos = troopIconImg.xPos + iconScaleWidth/2 - textWidth/2;
    //var yPos = troopIconImg.yPos + iconScaleHeight/2 + fontSize/2; 

    // left-middle
    //var xPos = troopIconImg.xPos; 
    //var yPos = troopIconImg.yPos + iconScaleHeight/2 + fontSize/2; 
   
    // bottom-middle position
    var xPos = troopIconImg.xPos + iconScaleWidth/2 - textWidth/2;
    var yPos = troopIconImg.yPos + iconScaleHeight - fontSize/2;

    context.strokeStyle = "black";
    context.lineWidth = 8;
    context.strokeText(troopReserveCount, xPos, yPos);

    context.fillStyle = "white";
    context.fillText(troopReserveCount, xPos, yPos);
  }

  function drawPlayerHandImage(image, playerHand) 
  {

    if (playerHand.length) {
      context.globalAlpha = solid;
    } else {
      context.globalAlpha = transparent;
    }

    context.drawImage(image, 
      image.xPos, image.yPos, 
      deckScaleWidth, deckScaleHeight);

    if (playerHand.length)
      drawHandCount(image, playerHand);


  }

  function drawLeaderDiscs() 
  {
    var leaderDiscs = images.leaders;

    //var discScaleWidth = 50;
    //var discScaleHeight = 50;

    var leaderCircle = {
      "centerX": 600,
      "centerY": canvas.height/2,
      "radius": 75,
      "angle": 0
    };

    var TO_RADIANS = Math.PI/180;
    var numberOfDiscs = 5;
    var centralAngle = 180/numberOfDiscs * TO_RADIANS;

    /* Calculate largest radius for 5 smaller circles that can fit in larger 
    * circle using steiner chain formula */
    var leaderDiscRadius = 
      leaderCircle.radius / ( (1 - Math.sin(centralAngle)) 
      / Math.sin(centralAngle) + 2 );

    for (var i = 0; i < numberOfDiscs; i++) {

      var degrees = 360 / numberOfDiscs;
      /* centralAngle arranges discs in star formation */
      leaderCircle.angle = (i * degrees * TO_RADIANS) - centralAngle/2;

      var x = leaderCircle.centerX + Math.cos(leaderCircle.angle) 
	* (leaderCircle.radius - leaderDiscRadius);
      var y = leaderCircle.centerY + Math.sin(leaderCircle.angle) 
	* (leaderCircle.radius - leaderDiscRadius);
      
      var leaderDiscImg = leaderDiscs[i];
      leaderDiscImg.xPos = x - leaderDiscRadius;
      leaderDiscImg.yPos = y - leaderDiscRadius;

      //discScaleWidth = discScaleHeight = 2 * leaderDiscRadius;
      leaderDiscImg.width = leaderDiscImg.height = 2 * leaderDiscRadius;
      context.drawImage(leaderDiscImg, 
	leaderDiscImg.xPos, leaderDiscImg.yPos, 
	leaderDiscImg.width, leaderDiscImg.height);
	//discScaleWidth, discScaleHeight);

    }
  }

  function drawEndTurnButton() {
    var text = "End Turn";

    var fontSize = 12;
    context.font = fontSize + "pt Arial";

    var textWidth = context.measureText(text).width;
    var xPos = canvas.width - textWidth;
    var yPos = canvas.height - fontSize;
    context.fillstyle = "black";
    context.fillText(text, xPos, yPos);

  }

  function loadPlayerHandImages()
  {
    loadTreacheryHand();
    loadTraitorHand();
    loadBonusHand();
    loadAllianceHand();
  }

  function loadTreacheryHand() 
  {
    var treacheryDeckImgUrl = deckImgPath + "treachery.png";
    treacheryDeckImg = loader.loadImage(treacheryDeckImgUrl);
    treacheryDeckImg.xPos = spiceIconImg.xPos + iconScaleWidth + padding;
    treacheryDeckImg.yPos = 10;
    treacheryDeckImg.width = deckScaleWidth;
    treacheryDeckImg.height = deckScaleHeight;
  }

  function loadTraitorHand()
  {
    var traitorDeckImgUrl = deckImgPath + "traitor.png";
    traitorDeckImg = loader.loadImage(traitorDeckImgUrl);
    traitorDeckImg.xPos = treacheryDeckImg.xPos + deckScaleWidth + padding;
    traitorDeckImg.yPos = padding;
    traitorDeckImg.width = deckScaleWidth;
    traitorDeckImg.height = deckScaleHeight;
  }

  function loadBonusHand()
  {
    var bonusDeckImgUrl = deckImgPath + "bonus.png";
    bonusDeckImg = loader.loadImage(bonusDeckImgUrl);
    bonusDeckImg.xPos = traitorDeckImg.xPos + deckScaleWidth + padding;
    bonusDeckImg.yPos = padding;
    bonusDeckImg.width = deckScaleWidth;
    bonusDeckImg.height = deckScaleHeight;
  }

  function loadAllianceHand()
  {
    var allianceDeckImgUrl = deckImgPath + "alliance.png";
    allianceDeckImg = loader.loadImage(allianceDeckImgUrl);
    allianceDeckImg.xPos = bonusDeckImg.xPos + deckScaleWidth + padding;
    allianceDeckImg.yPos = padding
    allianceDeckImg.width = deckScaleWidth;
    allianceDeckImg.height = deckScaleHeight;
  }


  function drawLeaderDiskStarFormation() 
  {
  }

  this.addTraitorCard = function(traitorCardImg) 
  {
    addCardToHand(traitorCardImg, traitorDeckImg);
    traitorCardImg.onHalt = function() { 
      traitorHand.push(traitorCardImg);
      canvas.redraw() 

      eventChain.next();
    }
  }

  this.addTreacheryCard = function(treacheryCardImg) 
  {
    addCardToHand(treacheryCardImg, treacheryDeckImg);
    treacheryCardImg.onHalt = function() { 
      treacheryHand.push(treacheryCardImg);
      canvas.redraw() 

      eventChain.next();
    }
  }

  this.addBonusCard = function(bonusCardImg) 
  {
    addCardToHand(bonusCardImg, bonusDeckImg);
    bonusCardImg.onHalt = function() { 
      bonusHand.push(bonusCardImg);
      canvas.redraw() 

      eventChain.next();
    }
  }

  function addCardToHand(cardImg, playerHandImg)
  {
    cardImg.canvas = canvas;
    cardImg.xPos = canvas.width;
    cardImg.yPos = playerHandImg.yPos;
    cardImg.speed = 0.02;
    cardImg.width = deckScaleWidth;
    cardImg.height = deckScaleHeight;

    cardImg.moveToCoord([playerHandImg.xPos, playerHandImg.yPos]);
  }

  function drawHandCount(playerHandImg, playerHand)
  {

    var handCount = playerHand.length;
    var fontSize = 25;
    context.font = fontSize + "pt Arial";

    var textWidth = context.measureText(handCount).width;
    var textPadding = 1.3

    var xPos = playerHandImg.xPos + deckScaleWidth - textWidth * textPadding;
    var yPos = playerHandImg.yPos + fontSize * textPadding;

    context.fillStyle = "white";
    context.fillText(handCount, xPos, yPos);

    if (that.onHandUpdate) {
      that.onHandUpdate();
      delete that.onHandUpdate;
    }

  }

  this.shipTroops = function(territoryName) 
  {
    var territoryObj = territoryView.getTerritory(territoryName);

    var troopTokenImg = getTroopTokenImg(territoryObj);

    troopReserveCount--;
    this.update();
    territoryObj.addFaction(troopTokenImg);
  }

  function getTroopTokenImg(territoryObj) 
  {
    var notificationCanvas = canvasContainer.layer("notification");
    notificationCanvas.redraw = function() 
    {
      var context = this.getContext("2d");
      context.clearRect(0, 0, this.width, this.height);
      territoryObj.draw();
    }

    var troopTokenImg = new Image();

    troopTokenImg.src = troopIconImg.src;
    troopTokenImg.faction = troopIconImg.faction;
    troopTokenImg.yPos = troopIconImg.yPos + notificationCanvas.height - canvas.height;
    troopTokenImg.xPos = troopIconImg.xPos;
    troopTokenImg.height = iconScaleHeight;
    troopTokenImg.width = iconScaleWidth;
    troopTokenImg.canvas = notificationCanvas;
    troopTokenImg.speed = 0.1;

    return troopTokenImg;
  }
}

function getMousePosition(canvasElement,e)
{
  var rect = canvasElement.getBoundingClientRect();
  var mousex = e.clientX - rect.left; 
  var mousey = e.clientY - rect.top;

  return {x: mousex, y: mousey};
}

