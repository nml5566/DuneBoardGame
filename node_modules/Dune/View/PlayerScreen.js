module.exports = PlayerScreen;

var controller = require("Dune/Controller");

var canvasContainer = require("Dune/CanvasContainer");
var Loader = require("Dune/Loader");
var eventChain = require("Dune/EventChain");

var territoryView = require("Dune/View/Territory");

function PlayerScreen(args) 
{
  var images = args.images;

  var layerName = "playerscreen";

  var canvas = canvasContainer.layer(layerName),
      context = canvas.getContext("2d"),
      loader = new Loader();


  canvas.height = 172;

  var deckImgPath = "/img/deck/";

  var spiceIconImg,
      troopIconImg,
      treacheryDeckImg,
      traitorDeckImg,
      bonusDeckImg,
      allianceDeckImg;


  var troopReserveCount = 20;

  var treacheryHand = [], traitorHand = [], bonusHand = [], allianceHand = [];

  var deckScaleWidth = 100;
  var deckScaleHeight = 145;

  var padding = 10;

  var transparent = 0.5;
  var solid = 1;

  var that = this;

  loadImages();

  function loadImages() {
    loadSpiceIcon();
    loadTroopIcon();
    loadPlayerHandImages();
    loader.onload = setImageProperties;
  }

  function loadSpiceIcon() 
  {
    var spiceIconImgUrl = "/img/icons/" + "spice-alt.png";
    spiceIconImg = loader.loadImage(spiceIconImgUrl);
  }

  function loadTroopIcon() 
  {
    var troopIconImgUrl = "/img/icons/troops/" + images.troop;
    troopIconImg = loader.loadImage(troopIconImgUrl);
  }

  function setImageProperties() 
  {
    troopIconImg.yPos = padding;
    setIconDimensions(troopIconImg);
    troopIconImg.faction = args.faction;

    spiceIconImg.yPos = troopIconImg.yPos + troopIconImg.width + padding;
    setIconDimensions(spiceIconImg);

    setTreacheryIconProperties();
    setTraitorIconProperties();
    setBonusIconProperties();
    setAllianceIconProperties();

    //allianceDeckImg.xPos = bonusDeckImg.xPos + deckScaleWidth + padding;
    //setCardDimensions(allianceDeckImg);
  }

  function setTreacheryIconProperties() {
    treacheryDeckImg.xPos = spiceIconImg.xPos + spiceIconImg.width + padding;
    setCardDimensions(treacheryDeckImg);

    treacheryDeckImg.triggerClickEvent = 
      function() { showPlayerHand(treacheryHand) }
  }

  function setTraitorIconProperties() {
    traitorDeckImg.xPos = treacheryDeckImg.xPos + deckScaleWidth + padding;
    setCardDimensions(traitorDeckImg);
    traitorDeckImg.triggerClickEvent = 
      function() { showPlayerHand(traitorHand) }
  }

  function setBonusIconProperties() {
    bonusDeckImg.xPos = traitorDeckImg.xPos + deckScaleWidth + padding;
    setCardDimensions(bonusDeckImg);
    bonusDeckImg.triggerClickEvent = 
      function() { showPlayerHand(bonusHand) }
  }

  function setAllianceIconProperties() {
    allianceDeckImg.xPos = bonusDeckImg.xPos + deckScaleWidth + padding;
    setCardDimensions(allianceDeckImg);
    allianceDeckImg.triggerClickEvent = 
      function() { showPlayerHand(allianceHand) }
  }

  function showPlayerHand(playerHand) {
    if (! playerHand.length) return;

    var notificationCanvas = canvasContainer.layer("notification");

    var cardScaleFactor = deckScaleHeight / deckScaleWidth;

    var mapHeight = notificationCanvas.height - canvas.height;

    var combinedCardPadding = padding * 4;
    var usableHeight = mapHeight - combinedCardPadding;
    var maxCardHeight = usableHeight/4;
    var maxCardWidth = deckScaleWidth * cardScaleFactor;


    for (var i = 0; i < playerHand.length; i++) {
      var cardImg = playerHand[i];

      var notificationContext = notificationCanvas.getContext("2d");
      //horizontal layout
      //var xPos = (i * (deckScaleWidth + padding) ) + padding;
      //var yPos = notificationCanvas.height - canvas.height - deckScaleHeight 
	//- padding; 

      // vertical layout
      var xPos = padding;

      var yPos =  mapHeight - maxCardHeight 
	- padding - (i * (maxCardHeight + padding)); 

      notificationContext.drawImage(cardImg, xPos, yPos
	  //,deckScaleWidth, deckScaleHeight);
	  ,maxCardWidth, maxCardHeight);
    }

    notificationCanvas.addEventListener('click', function(e) {
      canvasContainer.deleteLayer(notificationCanvas);
    });
  }

  function setIconDimensions(iconImg) 
  {
    var iconScaleSide = 67.5;
    iconImg.width = iconImg.height = iconScaleSide;
    iconImg.xPos = padding;
  }

  function setCardDimensions(cardImg) 
  {
    cardImg.yPos = padding
    cardImg.width = deckScaleWidth;
    cardImg.height = deckScaleHeight;
  }

  this.show = function() 
  {
    canvas.redraw = drawPlayerScreen;
    canvas.redraw();
    addClickEvent();
  }

  function addClickEvent() 
  {
    //TODO refactor player screen or canvas so that it doesn't get multiple
    //onclick events
    if (! canvas.isInteractive) {
      canvas.isInteractive = true;
      canvas.addEventListener('click', function(element) {
	var coord = getMousePosition(canvas,element);

	var icons = new Array(
	  spiceIconImg,
	  troopIconImg,
	  treacheryDeckImg,
	  traitorDeckImg,
	  bonusDeckImg,
	  allianceDeckImg
	);

	for (var i = 0; i < icons.length; i++) {
	  var image = icons[i];

	  if (coord.x >= image.xPos && coord.x <= image.xPos + image.width
	      && coord.y >= image.yPos && coord.y <= image.yPos + image.height
	      && image.triggerClickEvent
	  ) {
	    image.triggerClickEvent();
	    //console.log('clicked:');
	    //console.log(image);
	  }

	}

	//controller.startPlayerTurn();
      });
    }
  }

  this.hide = function() {
    drawBackground();
  }

  function drawPlayerScreen()
  {
    context.clearRect(0, 0, canvas.width, canvas.height);

    drawBackground();

    drawOffPlanetTroopReserves();

    context.drawImage(spiceIconImg, 
	spiceIconImg.xPos, spiceIconImg.yPos, 
	spiceIconImg.width, spiceIconImg.height);

    context.globalAlpha = transparent;

    drawPlayerHandImage(treacheryDeckImg, treacheryHand);
    drawPlayerHandImage(traitorDeckImg, traitorHand);
    drawPlayerHandImage(bonusDeckImg, bonusHand);
    drawPlayerHandImage(allianceDeckImg, allianceHand);

    context.globalAlpha = solid;

    drawLeaderDiscs();

    drawEndTurnButton();
  }

  function drawBackground() {
    context.fillStyle = "grey";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }

  function drawOffPlanetTroopReserves() {

    context.drawImage(troopIconImg, 
      troopIconImg.xPos, troopIconImg.yPos, 
      troopIconImg.width, troopIconImg.height);

    drawTroopReserveCount();
  }

  function drawTroopReserveCount() {
    var fontSize = 12;
    context.font = fontSize + "pt Arial";
    
    var textWidth = context.measureText(troopReserveCount).width;

    /* Troop count displays at bottom-middle of troop token */
    var xPos = troopIconImg.xPos + troopIconImg.width/2 - textWidth/2;
    //var yPos = troopIconImg.yPos + iconScaleHeight - fontSize/2;
    var yPos = troopIconImg.yPos + troopIconImg.height - fontSize/2;

    context.strokeStyle = "black";
    context.lineWidth = 8;
    context.strokeText(troopReserveCount, xPos, yPos);

    context.fillStyle = "white";
    context.fillText(troopReserveCount, xPos, yPos);
  }

  function drawPlayerHandImage(image, playerHand) 
  {

    if (playerHand.length) {
      context.globalAlpha = solid;
    } else {
      context.globalAlpha = transparent;
    }

    context.drawImage(image, 
      image.xPos, image.yPos, 
      deckScaleWidth, deckScaleHeight);

    if (playerHand.length)
      drawHandCount(image, playerHand);


  }

  function drawLeaderDiscs() 
  {
    var leaderDiscs = images.leaders;

    var leaderCircle = {
      "centerX": 600,
      "centerY": canvas.height/2,
      "radius": 75,
      "angle": 0
    };

    var TO_RADIANS = Math.PI/180;
    var numberOfDiscs = 5;
    var centralAngle = 180/numberOfDiscs * TO_RADIANS;

    /* Calculate largest radius for 5 smaller circles that can fit in larger 
    * circle using steiner chain formula */
    var leaderDiscRadius = 
      leaderCircle.radius / ( (1 - Math.sin(centralAngle)) 
      / Math.sin(centralAngle) + 2 );

    for (var i = 0; i < numberOfDiscs; i++) {

      var degrees = 360 / numberOfDiscs;
      /* centralAngle arranges discs in star formation */
      leaderCircle.angle = (i * degrees * TO_RADIANS) - centralAngle/2;

      var x = leaderCircle.centerX + Math.cos(leaderCircle.angle) 
	* (leaderCircle.radius - leaderDiscRadius);
      var y = leaderCircle.centerY + Math.sin(leaderCircle.angle) 
	* (leaderCircle.radius - leaderDiscRadius);
      
      var leaderDiscImg = leaderDiscs[i];
      leaderDiscImg.xPos = x - leaderDiscRadius;
      leaderDiscImg.yPos = y - leaderDiscRadius;

      leaderDiscImg.width = leaderDiscImg.height = 2 * leaderDiscRadius;
      context.drawImage(leaderDiscImg, 
	leaderDiscImg.xPos, leaderDiscImg.yPos, 
	leaderDiscImg.width, leaderDiscImg.height);
    }
  }

  function drawEndTurnButton() {
    var text = "End Turn";

    var fontSize = 12;
    context.font = fontSize + "pt Arial";

    var textWidth = context.measureText(text).width;
    var xPos = canvas.width - textWidth;
    var yPos = canvas.height - fontSize;
    context.fillstyle = "black";
    context.fillText(text, xPos, yPos);

  }

  function loadPlayerHandImages()
  {
    loadTreacheryHand();
    loadTraitorHand();
    loadBonusHand();
    loadAllianceHand();
  }

  function loadTreacheryHand() 
  {
    var treacheryDeckImgUrl = deckImgPath + "treachery.png";
    treacheryDeckImg = loader.loadImage(treacheryDeckImgUrl);
  }

  function loadTraitorHand()
  {
    var traitorDeckImgUrl = deckImgPath + "traitor.png";
    traitorDeckImg = loader.loadImage(traitorDeckImgUrl);
   }

  function loadBonusHand()
  {
    var bonusDeckImgUrl = deckImgPath + "bonus.png";
    bonusDeckImg = loader.loadImage(bonusDeckImgUrl);
    }

  function loadAllianceHand()
  {
    var allianceDeckImgUrl = deckImgPath + "alliance.png";
    allianceDeckImg = loader.loadImage(allianceDeckImgUrl);
  }


  this.addTraitorCard = function(traitorCardImg) 
  {
    addCardToHand(traitorCardImg, traitorDeckImg);
    addCardOnHaltEvent(traitorCardImg, traitorHand);
  }

  this.addTreacheryCard = function(treacheryCardImg) 
  {
    addCardToHand(treacheryCardImg, treacheryDeckImg);
    addCardOnHaltEvent(treacheryCardImg, treacheryHand);
  }

  this.addBonusCard = function(bonusCardImg) 
  {
    addCardToHand(bonusCardImg, bonusDeckImg);
    addCardOnHaltEvent(bonusCardImg, bonusHand);
  }

  function addCardToHand(cardImg, playerHandImg)
  {
    cardImg.canvas = canvas;
    cardImg.xPos = canvas.width;
    cardImg.yPos = playerHandImg.yPos;
    cardImg.speed = 0.02;
    cardImg.width = deckScaleWidth;
    cardImg.height = deckScaleHeight;

    cardImg.moveToCoord([playerHandImg.xPos, playerHandImg.yPos]);
  }

  function addCardOnHaltEvent(cardImg, cardHand) {
    cardImg.onHalt = function() { 
      cardHand.push(cardImg);
      canvas.redraw() 
      eventChain.next();
    }
  }

  function drawHandCount(playerHandImg, playerHand)
  {

    var handCount = playerHand.length;
    var fontSize = 25;
    context.font = fontSize + "pt Arial";

    var textWidth = context.measureText(handCount).width;
    var textPadding = 1.3

    var xPos = playerHandImg.xPos + deckScaleWidth - textWidth * textPadding;
    var yPos = playerHandImg.yPos + fontSize * textPadding;

    context.fillStyle = "white";
    context.fillText(handCount, xPos, yPos);

    if (that.onHandUpdate) {
      that.onHandUpdate();
      delete that.onHandUpdate;
    }

  }

  this.shipTroops = function(territoryName) 
  {
    var territoryObj = territoryView.getTerritory(territoryName);

    var troopTokenImg = getTroopTokenImg(territoryObj);

    troopReserveCount--;
    canvas.redraw();
    territoryObj.addFaction(troopTokenImg);
  }

  function getTroopTokenImg(territoryObj) 
  {
    var notificationCanvas = canvasContainer.layer("notification");
    notificationCanvas.redraw = function() 
    {
      var context = this.getContext("2d");
      context.clearRect(0, 0, this.width, this.height);
      territoryObj.draw();
    }

    var troopTokenImg = new Image();

    if (! troopIconImg.faction) 
      throw new Error ('Troop image has no faction property');

    troopTokenImg.src = troopIconImg.src;
    troopTokenImg.faction = troopIconImg.faction;
    troopTokenImg.yPos = troopIconImg.yPos + notificationCanvas.height - canvas.height;
    troopTokenImg.xPos = troopIconImg.xPos;
    troopTokenImg.height = troopTokenImg.width = troopIconImg.width;
    troopTokenImg.canvas = notificationCanvas;
    troopTokenImg.speed = 0.1;

    return troopTokenImg;
  }
}

function getMousePosition(canvasElement,e)
{
  var rect = canvasElement.getBoundingClientRect();
  var mousex = e.clientX - rect.left; 
  var mousey = e.clientY - rect.top;

  return {x: mousex, y: mousey};
}

