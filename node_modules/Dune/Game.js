module.exports = Game;

var ArrakisMap = require("./Map");
var shuffleArray = require("./shuffle");
var spiceDeck = require("Dune/Deck/Spice");

function Game() {

  var currentRound = 0;
  var lastRound = 15;

  var isStarted = false,
      factions = { },
      playerSeat = { },
      traitorPool;

  this.map = new ArrakisMap();

  this.start = function() {
    isStarted = true;
    assignPlayerSeats();
    makeTraitorPool();
  }

  function makeTraitorPool() {
  /* Generate a pool of traitors that each player will choose from */
    var allLeaders = new Array();
    for (var factionName in factions) {
      var faction = factions[factionName];
      var factionLeaders = faction.leaders();
      allLeaders = allLeaders.concat(factionLeaders);
    }

    shuffleArray(allLeaders);
    traitorPool = allLeaders;
  }


  this.selectPlayer = function(factionName) {
    if (isStarted) 
      throw new Error("Unable to add more players. Game has already started");

    if (! factions[factionName]) {
      var FactionModule = getFactionModule(factionName);
      factions[factionName] = new FactionModule(this);
    }

    return factions[factionName];
  }

  function getFactionModule(factionName) {
    switch(factionName) {
      case "Atreides":
	return require("./Faction/Atreides");
      case "BeneGesserit":
	return require("./Faction/BeneGesserit");
      case "Harkonnen":
	return require("./Faction/Harkonnen");
      case "Fremen":
	return require("./Faction/Fremen");
      case "Guild":
	return require("./Faction/Guild");
      case "Emperor":
	return require("./Faction/Emperor");
      default:
      	throw new Error("Invalid faction: " + factionName);
    }
  }

  function assignPlayerSeats() {
    var playerSeatSectors = new Array(1, 4, 7, 10, 13,16);
    shuffleArray(playerSeatSectors);

    for (var name in factions) {
      var faction = factions[name];
      faction.seat = playerSeatSectors.shift();
    }
  }

  this.dealTraitorHand = function() {

    return traitorPool.splice(0,4);
  }

  this.dealTreacheryCard = function() {
  }

  this.stormRound = function () {
    var stormMovement = this.map.moveStorm();
    return stormMovement;
  }

  this.spiceBlowRound = function() {
    var drawnTerritoriesCount = 0;

    var spiceCards = [];

    while (drawnTerritoriesCount < 2) 
    {
      var spiceCard = spiceDeck.dealCard();
      spiceCards.push(spiceCard);

      if (spiceCard.spice) 
	drawnTerritoriesCount++;
    }

    return spiceCards;
  }

  this.getTurnOrder = function() {
    var turnOrder = new Array();
    for (var name in factions) {
      var faction = factions[name];
      turnOrder.push(faction);
    }

    /* Storms on the same quadrant as player are considered ahead of it 
    /* so round up to illustrate this and prevent equal sorting problems */
    var tempSector = this.map.stormSector - 0.5

    var aSortFirst = -1;
    var bSortFirst = 1;
    return turnOrder.sort(function sortCounterClockwiseAheadOfStorm(a,b) { 

      var tempAngle = convertSectorNumberToMapAngle(tempSector);
      var angleA = convertSectorNumberToMapAngle(a.seat);
      var angleB = convertSectorNumberToMapAngle(b.seat);

      if (tempAngle > angleA && tempAngle < angleB)
      	return aSortFirst;

      if (tempAngle < angleA && tempAngle > angleB)
      	return bSortFirst;

      var distanceToA = tempAngle - angleA;
      var distanceToB = tempAngle - angleB;

      if (distanceToA < distanceToB) 
      	return aSortFirst;

      if (distanceToA > distanceToB)
      	return bSortFirst;

      throw new Error("Player seats are equal. This shouldn't happen")

    });
  }

  convertSectorNumberToMapAngle = function(sectorNumber) {
    var degreesPerSector = 20;
    
    /* Dividing by 2 puts the angle in the center of the sector */
    var degrees = (sectorNumber * degreesPerSector) + degreesPerSector/2; 
    var radians = degrees * (Math.PI/180);
    return degrees;
  }

  this.battleRound = function() {
  }

  this.collectionRound = function() {
  }

  this.controlRound = function() {
    currentRound++;
  }

  this.isOver = function() {
    return currentRound == lastRound;
  }

  this.bidRound = function() 
  {
    return new BidRound(this);
  }
}

function BidRound(game)
{
  var bidders = game.getTurnOrder();
  var startBidIndex = 0;
  var currentBidIndex = 0;
  var passes = { };

  var minimumBid = 1;

  var treacheryCardsToAuction;

  dealTreacheryCardsToAuction()

  function dealTreacheryCardsToAuction()
  {
    treacheryCardsToAuction = new Array();
    for (var i = 0; i < bidders.length; i++)
    {
      var treacheryCard = game.dealTreacheryCard();
      treacheryCardsToAuction.push(treacheryCard);
    }
  }

  this.minimumBid = function() { return minimumBid }
  this.increaseMinimumBid = function(spiceBid) { minimumBid += spiceBid }

  this.nextBidder = function()
  {
    var nextBidder = bidders[currentBidIndex];
    nextBidder.bidRound = this;
    setNextValidBidIndex();
  
    return nextBidder;
  }

  function setNextValidBidIndex()
  {
    currentBidIndex++;

    if (passes[currentBidIndex]) setNextValidBidIndex();

    if (currentBidIndex == bidders.length) currentBidIndex = 0;

    if (currentBidIndex == startBidIndex) 
    { 
      startBidIndex++
      currentBidIndex = startBidIndex;
    }
  }

  this.passCurrentBidder = function() 
  {
    passes[currentBidIndex] = true;
    checkIfBidWon();
  }

  function checkIfBidWon() 
  {
    if (Object.keys(passes).length == bidders.length - 1)
    {
      setNextValidBidIndex();
      var winningBidder = bidders[currentBidIndex];
      var topTreacheryCard = treacheryCardsToAuction.shift();
      winningBidder.takeTreacheryCard(topTreacheryCard);

      passes = new Array();
    }
  }
}

function TreacheryDeck() {
  return new Array();
}

