module.exports = GameController;

var DuneGame = require("Dune/Game");
var MapView = require("./View/Map");
var StartMenuView = require("./View/StartMenu");
var FactionSelectView = require("./View/FactionSelect");

function GameController() {

  var turn = 0;
  var traitorPool = new Array();

  this.game = new DuneGame();
  this.canvasContainer = new CanvasContainer();
  this.Loader = Loader;

  this.players = { };
  this.views = {
    "map": new MapView(this),
    "start": new StartMenuView(this),
    "factionSelect":new FactionSelectView(this),
    "factions": {}
  };

  var that = this;

  this.startGame = function() {
    this.game.start();

    hideFactionSelectView();
    initViews();
    this.startInitialPlayerTurn();
  }

  function hideFactionSelectView()
  {
    var views = that.views;
    var factionSelectView = views.factionSelect;
    factionSelectView.hide();
  }

  function initViews() {
    initFactionViews();
    initMapView();
  }

  function initFactionViews() {
    for (var factionName in that.players) {
      var FactionView = getFactionViewConstructor(factionName);
      var factionView = new FactionView(that);
      factionView.loadImages();
      that.views.factions[factionName] = factionView;
    }
  }

  function getFactionViewConstructor(factionName) {
    switch(factionName) {
      case "Atreides":
      	return require("./View/Faction/Atreides");
      case "Harkonnen":
      	return require("./View/Faction/Harkonnen");
      case "BeneGesserit":
      	return require("./View/Faction/BeneGesserit");
      case "Fremen":
      	return require("./View/Faction/Fremen");
      case "Guild":
      	return require("./View/Faction/Guild");
      case "Emperor":
      	return require("./View/Faction/Emperor");
      default:
      	throw new Error("Invalid faction view: "+factionName);
    }
  }


  this.setFactions = function (factionsArray) {
    for (var i = 0; i < factionsArray.length; i++) {
      var factionName = factionsArray[i];
      var player = this.game.selectPlayer(factionName);
      this.players[factionName] = player;
    }
  }

  function initMapView() {
    that.views.map.show();
    that.views.map.loadImages();
  }

  this.startInitialPlayerTurn = function() {
    var turnOrder = this.game.getTurnOrder();
    var faction = turnOrder[0];

    var factionView = this.views.factions[faction.constructor.name];

    factionView.startInitialTurn();
  }  

}

function CanvasContainer() 
{

  var container = document.getElementById("gamecontainer");

  var layerMap = { };
  var layerOrder = [];
  var zIndexMin = 99;
  
  this.layer = function(layerName) {
    if (! layerMap[layerName]) 
      newLayer(layerName);

    return layerMap[layerName]
  }

  function newLayer(layerName) {
    var canvas = document.createElement("canvas");

  
    layerMap[layerName] = canvas;

    /* Start layers at bottom to prevent newLayer() race conditions*/
    /* Code should manually call moveLayerToTop() */
    layerOrder.push(canvas);

    setCanvasAttributes(canvas, layerName);

    container.appendChild(canvas);
  }

  function setCanvasAttributes(canvas, layerName) {
    var zIndex = zIndexMin - layerOrder.length;

    canvas.id = layerName;
    canvas.className = "gamelayer";
    canvas.style.display = "block";
    canvas.style.zIndex = zIndex;
    canvas.width = 768;
    canvas.height = 1024;

  }

  this.moveLayerToTop = function(canvas) {
    var newIndex = 0;
    var oldIndex = getLayerIndex(canvas);

    layerOrder.splice(newIndex, 0, layerOrder.splice(oldIndex, 1)[0]);
    canvas.style.zIndex = zIndexMin + layerOrder.length;

  }

  function getLayerIndex(canvas) {
    for (var i = 0; i < layerOrder.length; i++) {
      var layer = layerOrder[i];
      if (layer.id == canvas.id) {
      	return i;
      }
    }

    throw new Error("Canvas element " + canvas.id + " not in layers");
  }

  this.deleteLayer = function(canvas) 
  {
    var canvasIndex = getLayerIndex(canvas);
    layerOrder.splice(canvasIndex, 1);
    delete layerMap[canvas.id];

    container.removeChild(canvas);
  }
}

function Loader() {

    var isLoaded = true,
        assetsLoaded = 0, 
        assetsToLoad = 0, 
        loadingScreen = document.getElementById('loadingscreen'),
	loadingMessage = document.getElementById('loadingmessage');

    var that = this;
    
    this.loadImage = function(url) {
      assetsToLoad++;
      this.isLoaded = false;

      var loadingScreen = document.getElementById('loadingscreen');
      loadingScreen.style.display = "block";

      var image = new Image();

      image.src = url;
      image.xPos = 0;
      image.yPos = 0;
      image.speed = 0.01;
      image.onload = this.itemLoaded;

      return image;
    };

    this.itemLoaded = function () {
      assetsLoaded++;

      loadingMessage.innerHTML = 
	'isLoaded '+assetsLoaded+' of '+assetsToLoad;

      if (assetsLoaded == assetsToLoad){
	this.isLoaded = true;

	hideLoadingScreen();

	//and call the object onload method if it exists
	if(that.onload){
	    that.onload();
	    that.onload = undefined;
	}
      }
    }

    function hideLoadingScreen() {
      loadingScreen.style.display = "none";
    }
}

Image.prototype.moveToCoord = function(point) {
  var image = this;

  if (!image.canvas) {
    throw new Error("Image has no canvas property");
    return;
  }


  var finalX = point[0],
      finalY = point[1];

  image.xStep = (finalX - image.xPos) * image.speed;
  image.yStep = (finalY - image.yPos) * image.speed;

  image.movement = setInterval(function () {
    image.animateMovement([finalX, finalY]);
  }, 10);

}

Image.prototype.animateMovement = function(point) {
  var image = this;

  var canvas = image.canvas;
  var context = canvas.getContext("2d");;

  var x = point[0];
  var y = point[1];

  image.xPos += image.xStep;
  image.yPos += image.yStep;

  canvas.redraw();
  context.drawImage(image, 
    image.xPos, image.yPos,
    image.width, image.height
  );


  if (
    image.yStep > 0 && image.yPos + image.yStep >= y ||
    image.yStep < 0 && image.yPos + image.yStep <= y || 
    image.xStep > 0 && image.xPos + image.xStep >= x ||
    image.xStep < 0 && image.xPos + image.xStep <= x
  )
  {
    clearInterval(image.movement);
    delete image.movement;
    delete image.xStep;
    delete image.yStep;

    image.xPos = x
    image.yPos = y

    canvas.redraw();
    context.drawImage(image, 
      image.xPos, image.yPos,
      image.width, image.height
    );

    if (this.onHalt) {
      var onHalt = this.onHalt;
      delete this.onHalt;
      onHalt();
    }

  }
}
